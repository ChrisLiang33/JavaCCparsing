/*
 * This is parse.jj
 */

options {
  IGNORE_CASE = false;
}

PARSER_BEGIN(parse)
class parse {
    /** Main entry point. */
  public static void main(String args[]) throws ParseException {
    parse parser = new parse(System.in);
    parser.Program();
  }

}
PARSER_END(parse)

SKIP: /* Whitespace */
{
  "\t"
| "\n"
| "\r"
| " "
}


TOKEN:
{
   <LPAREN:    "(" >
|  <RPAREN:    ")" >
|  <PLUS:    "+"> 
| <MINUS: "-" >
|  <MULTIPLY:   "*">
| <DIVIDE:  "/" >
|  < INTEGER_LITERAL: (["0"-"9"])+ >
|  <CLASS:"class">
|  <IF: "if">
| <ELSE: "else">
|<STRING_ARRAY: "String []">
|<PUBLIC: "public">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <THIS: "this">
| <PERIOD: ".">
| <WHILE: "while">
| <EXTENDS: "extends">
| <BOOLEAN: "boolean">
| <TRUE: "true">
| <FALSE: "false">
| <INT: "int">
| <LENGTH: "length">
| <INT_ARRAY: "int []">
| <NEW: "new">
| <NOT: "!">
| <EQUALS: "=">
| <COMMA: ",">
| <IDENTIFIER: (["a"-"z", "A"-"Z"])+ (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
| <LBRACKET: "[">
| <RBRACKET: "]">
| <LCBRACKET: "{">
| <RCBRACKET: "}">
| <SEMICOLON: ";">
| <LESS_THAN: ">">
| <MORE_THAN: "<">
| <RETURN: "return">
| <AND: "&&">
| <OR: "||">
|<COMMENT: "//">
| <OPERATOR: "&&"|"<"|"+"|"-"|"*">
| <PRINT: "System.out.println">
}


/* Program Syntax */

// 
// grammar for mini java
// E  -> MainClass ClassDecl*
// MainClass -> class id { public static void main ( String [] id ) { Statement } }
// ClassDecl -> class id { VarDecl MethodDecl } | class id extends id { VarDecl MethodDecl }
// VarDecl -> Typeid;
// MethodDecl -> public Type id ( FormalList ) ExpList ExpRest
// id
//
//
// 



void Program():
{}
{
    MainClass() ((ClassDecl())*) <EOF>
}

void MainClass():
{}
{
    <CLASS>id()<LCBRACKET> <PUBLIC><STATIC><VOID><MAIN><LPAREN><<STRING_ARRAY>id()<RPAREN><LCBRACKET>Statement()<RCBRACKET><RCBRACKET
}

void ClassDecl():
{}
{
    <CLASS><IDENTIFIER><LCBRACKET>((VarDecl())*) (MethodDecl()*) <RCBRACKET>
    |
    <CLASS><IDENTIFIER><EXTENDS> <IDENTIFIER> <LCBRACKET> (VarDecl()*) (MethodDecl()*) <RCBRACKET>
}

void VarDecl():
{}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDecl():
{}
{
    <PUBLIC> Type() <IDENTIFIER> <LPAREN>FormalList() <RPAREN><LCBRACKET> (VarDecl()*) (Statement()*) <RETURN> Exp() <SEMICOLON><RCBRACKET>
}

void FormalList():
{}
{
    Type() <IDENTIFIER> (FormalRest()*)
    |
    {}
}

void FormalRest():
{}
{
  <COMMA> Type() <IDENTIFIER>
}

void Type():
{}
{
  <INT_ARRAY>
  |
  <BOOLEAN>
  |
  <INT>
  |
  <IDENTIFIER>
}
void Statement():
{}
{
  <LCBRACKET>(Statement())*<RCBRACKET> 
  |
  <IF><LPAREN>Exp()<RPAREN>Statement()<ELSE>Statement()
  |
  <WHILE> Exp() Statement()
  |
  <PRINT><LPAREN>Exp()<RPAREN><SEMICOLON
  |
  <IDENTIFIER><EQUALS> Exp() <SEMICOLON
  |
  <IDENTIFIER><LBRACKET>Exp()<RBRACKET> <EQUALS> Exp() <SEMICOLON>
}

void Exp():
{}
{
  <INTEGER_LITERAL> 
  |
  <TRUE> 
  |
  <FALSE> 
  |
  <IDENTIFIER> 
  |
  <THIS>
  |
  <NEW><IDENTIFIER><LPAREN><RPAREN>
  |
  <NEW><INT><LBRACKET> Exp()<RBRACKET> Exp1()
  |
  <LPAREN>Exp()<RPAREN> Exp1()
  |
  <NOT>Epx() Exp1()
}

void Exp1():
{}
{
  <OPERATOR> Exp() Exp1()
  |
  <LBRACKET>Exp()<RBRACKET> Exp1()
  |
  <PERIOD> <LENGTH> Exp1()
  |
  <PERIOD> <IDENTIFIER> <LPAREN> ExpList() <RPAREN> Exp1()
  |
  {}
}


void ExpList():
{}
{
  Exp() ExpRest()*
}

void ExpRest():
{}
{
  <COMMA> Exp()
}


