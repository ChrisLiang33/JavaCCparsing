/*
 * This is parse.jj
 */

options {
  IGNORE_CASE = false;
}

PARSER_BEGIN(parse)
import java.io.*;
public class parse
{
    public static void main(String args[]) throws ParseException 
    {
        parse parser = new parse(System.in);
        parser.Program();
    }
}
PARSER_END(parse)

SKIP: /* Whitespace */
{
  "\t"
| "\n"
| "\r"
| " "
| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* >
| <MULTI_LINE_COMMENT: "/*" (~["*"] | "*" ~["/", "*"])* "*" "/" >
}


TOKEN:
{
   <LPAREN:    "(" >
|  <RPAREN:    ")" >
//| <OPERATOR: "&&"|"<"|"+"|"-"|"*">
| <ADD_OP: "+"|"-">
//|  <PLUS:    "+"> 
//| <MINUS: "-" >
|  <MULTIPLY:   "*">
| <DIVIDE:  "/" >
|  < INTEGER_LITERAL: (["0"-"9"])+ >
|  <CLASS:"class">
|  <IF: "if">
| <ELSE: "else">
|  <STRING: "String"> //<STRING_ARRAY: "String []">
|<PUBLIC: "public">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <THIS: "this">
| <PERIOD: ".">
| <WHILE: "while">
| <EXTENDS: "extends">
| <BOOLEAN: "boolean">
| <TRUE: "true">
| <FALSE: "false">
| <INT: "int">
| <LENGTH: "length">
| <INT_ARRAY: "int []">
| <NEW: "new">
| <NOT: "!">
| <EQUALS: "=">
| <COMMA: ",">
| <RETURN: "return">
| <IDENTIFIER: (["a"-"z", "A"-"Z"])+ (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
| <LBRACKET: "[">
| <RBRACKET: "]">
| <LCBRACKET: "{">
| <RCBRACKET: "}">
| <SEMICOLON: ";">
| <LESS_THAN: "<">
| <MORE_THAN: ">">
| <AND: "&&">
//| <OR: "||">
| <PRINT: "System.out.println">
//| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* >
//| <MULTI_LINE_COMMENT: "/*" (~["*"] | "*" ~["/", "*"])* "*" "/" >
}


/* Program Syntax */

// 
// grammar for mini java
// E  -> MainClass ClassDecl*
// MainClass -> class id { public static void main ( String [] id ) { Statement } }
// ClassDecl -> class id { VarDecl MethodDecl } | class id extends id { VarDecl MethodDecl }
// VarDecl -> Typeid;
// MethodDecl -> public Type id ( FormalList ) ExpList ExpRest
// id
//
//
// 



void Program():
{}
{
    MainClass() ((ClassDecl())*) 
    {System.out.println("parsable");}
    <EOF>
}

void MainClass():
{}
{
    <CLASS><IDENTIFIER><LCBRACKET> <PUBLIC><STATIC><VOID><MAIN><LPAREN><STRING><LBRACKET><RBRACKET><IDENTIFIER><RPAREN><LCBRACKET>Statement() <RCBRACKET><RCBRACKET>
}

void ClassDecl():
{}
{
    <CLASS><IDENTIFIER>(<EXTENDS><IDENTIFIER>)?<LCBRACKET>(VarDecl())* (MethodDecl())* <RCBRACKET>
    //|
    //<CLASS><IDENTIFIER><EXTENDS> <IDENTIFIER> <LCBRACKET> (VarDecl())* (MethodDecl())* <RCBRACKET>
}

void VarDecl():
{}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDecl():
{ }
{
 <PUBLIC> Type() <IDENTIFIER> <LPAREN>FormalList() <RPAREN><LCBRACKET>
  (LOOKAHEAD(2) VarDecl())* (Statement())* <RETURN> Exp() <SEMICOLON> <RCBRACKET>
}

void FormalList():
{}
{
    Type() <IDENTIFIER> (FormalRest())*
    |
    {}
}

void FormalRest():
{}
{
  <COMMA> Type() <IDENTIFIER>
}

void Type():
{}
{
  <INT_ARRAY>
  |
  <BOOLEAN>
  |
  <INT>
  |
  <IDENTIFIER>
}
void Statement():
{ Token t; }
{
  (
  t =<LCBRACKET>(Statement())*<RCBRACKET> 
  |
  t =<IF><LPAREN>Exp()<RPAREN>Statement()<ELSE>Statement()
  |
  t =<WHILE> Exp() Statement()
  |
  t =<PRINT><LPAREN>Exp()<RPAREN><SEMICOLON>
  |
  LOOKAHEAD(2) t = <IDENTIFIER><EQUALS> Exp() <SEMICOLON>
  |
  LOOKAHEAD(2) t=<IDENTIFIER><LBRACKET>Exp()<RBRACKET> <EQUALS> Exp() <SEMICOLON>
  )
}

void Exp():
{}
{
  Exp4()
}

void Exp4():
{}
{
  Exp9()  Exp4a()
}

void Exp4a():
{}
{
  <AND> Exp9() Exp4a()
  |
  {}
}

void Exp9():
{}
{
  Exp11() Exp9a()
}

void Exp9a():
{}
{
  <LESS_THAN> Exp11() Exp9a()
  |
  {}
}
void Exp11():
{}
{
  Exp12() Exp11a()
}

void Exp11a():
{}
{
  <ADD_OP> Exp12() Exp11a()
  |
  {}
}

void Exp12():
{}
{
  Exp14() Exp12a()
}

void Exp12a():
{}
{
  <MULTIPLY> Exp14() Exp12a()
  |
  {}
}

void Exp14():
{}
{
  Exp16() Exp14a()
}

void Exp14a():
{}
{
  <NOT> Exp16() Exp14a()
  |
  {}
}

void Exp16():
{ Token t;}
{
  (
    t = <INTEGER_LITERAL> Exp()
    |
    t = <TRUE> Exp()
    |
    t = <FALSE> Exp()
    |
    t = <IDENTIFIER> Exp()
    |
    t = <THIS> Exp()
    |
    LOOKAHEAD(2) t =<NEW><IDENTIFIER><LPAREN><RPAREN> Expa() Exp()
    |
    LOOKAHEAD(2) t =<NEW><INT><LBRACKET> Exp()<RBRACKET> Expa() Exp()
    | 
    t = <LPAREN>Exp()<RPAREN> Expa() Exp()
    | 
    Expa()
  )
}
void Expa():
{ Token t; }
{
  (
 // t=<OPERATOR> Exp() Expa()
 // |
  t=<LBRACKET>Exp()<RBRACKET> Expa()
  |
  LOOKAHEAD(2) t=<PERIOD> <LENGTH> Expa()
  |
  LOOKAHEAD(2) t=<PERIOD> <IDENTIFIER> <LPAREN> ExpList() <RPAREN> Expa()
  |
  {}
  )
}


void ExpList():
{}
{
  Exp() (ExpRest())*
}

void ExpRest():
{}
{
  <COMMA> Exp()
}


