/*
 * This is parse.jj
 */

options {
  IGNORE_CASE = false;
}

PARSER_BEGIN(parse)
import java.io.*;
public class parse
{
    public static void main(String args[]) throws ParseException 
    {
        parse parser = new parse(System.in);
        parser.Program();
    }
}
PARSER_END(parse)

SKIP: /* Whitespace */
{
  "\t"
| "\n"
| "\r"
| " "
| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* >
| <MULTI_LINE_COMMENT: "/*" (~["*"] | "*" ~["/", "*"])* "*" "/" >
}


TOKEN:
{
   <LPAREN:    "(" >
|  <RPAREN:    ")" >
| <OPERATOR: "&&"|"<"|"+"|"-"|"*">
|  <PLUS:    "+"> 
| <MINUS: "-" >
|  <MULTIPLY:   "*">
| <DIVIDE:  "/" >
|  < INTEGER_LITERAL: (["0"-"9"])+ >
|  <CLASS:"class">
|  <IF: "if">
| <ELSE: "else">
|  <STRING: "String"> //<STRING_ARRAY: "String []">
|<PUBLIC: "public">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <THIS: "this">
| <PERIOD: ".">
| <WHILE: "while">
| <EXTENDS: "extends">
| <BOOLEAN: "boolean">
| <TRUE: "true">
| <FALSE: "false">
| <INT: "int">
| <LENGTH: "length">
| <INT_ARRAY: "int []">
| <NEW: "new">
| <NOT: "!">
| <EQUALS: "=">
| <COMMA: ",">
| <RETURN: "return">
| <IDENTIFIER: (["a"-"z", "A"-"Z"])+ (["a"-"z", "A"-"Z", "0"-"9", "_"])* >
| <LBRACKET: "[">
| <RBRACKET: "]">
| <LCBRACKET: "{">
| <RCBRACKET: "}">
| <SEMICOLON: ";">
| <LESS_THAN: ">">
| <MORE_THAN: "<">
| <AND: "&&">
| <OR: "||">
| <PRINT: "System.out.println">
//| <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* >
//| <MULTI_LINE_COMMENT: "/*" (~["*"] | "*" ~["/", "*"])* "*" "/" >
}


/* Program Syntax */

// 
// grammar for mini java
// E  -> MainClass ClassDecl*
// MainClass -> class id { public static void main ( String [] id ) { Statement } }
// ClassDecl -> class id { VarDecl MethodDecl } | class id extends id { VarDecl MethodDecl }
// VarDecl -> Typeid;
// MethodDecl -> public Type id ( FormalList ) ExpList ExpRest
// id
//
//
// 



void Program():
{}
{
    MainClass() ((ClassDecl())*) 
    {System.out.println("parsable");}
    <EOF>
}

void MainClass():
{}
{
    <CLASS><IDENTIFIER><LCBRACKET> <PUBLIC><STATIC><VOID><MAIN><LPAREN><STRING><LBRACKET><RBRACKET><IDENTIFIER><RPAREN><LCBRACKET>Statement() <RCBRACKET><RCBRACKET>
}

void ClassDecl():
{}
{
    <CLASS><IDENTIFIER>(<EXTENDS><IDENTIFIER>)?<LCBRACKET>(VarDecl())* (MethodDecl())* <RCBRACKET>
    //|
    //<CLASS><IDENTIFIER><EXTENDS> <IDENTIFIER> <LCBRACKET> (VarDecl())* (MethodDecl())* <RCBRACKET>
}

void VarDecl():
{}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDecl():
{}
{
    <PUBLIC> Type() <IDENTIFIER> <LPAREN>FormalList() <RPAREN><LCBRACKET> 
    (VarDecl())* 
    (Statement())* 
    <RETURN> Exp() <SEMICOLON> <RCBRACKET>
}

void FormalList():
{}
{
    Type() <IDENTIFIER> (FormalRest())*
    |
    {}
}

void FormalRest():
{}
{
  <COMMA> Type() <IDENTIFIER>
}

void Type():
{}
{
  <INT_ARRAY>
  |
  <BOOLEAN>
  |
  <INT>
  |
  <IDENTIFIER>
}
void Statement():
{ Token t; }
{
  (
  t =<LCBRACKET>(Statement())*<RCBRACKET> 
  |
  t =<IF><LPAREN>Exp()<RPAREN>Statement()<ELSE>Statement()
  |
  t =<WHILE> Exp() Statement()
  |
  t =<PRINT><LPAREN>Exp()<RPAREN><SEMICOLON>
  |
  LOOKAHEAD(2) t = <IDENTIFIER><EQUALS> Exp() <SEMICOLON>
  |
  LOOKAHEAD(2) t=<IDENTIFIER><LBRACKET>Exp()<RBRACKET> <EQUALS> Exp() <SEMICOLON>
  )
}

void Exp():
{ Token t; }
{
  (
    t =<INTEGER_LITERAL> Exp1()
  |
  t =<TRUE> Exp1()
  |
  t =<FALSE> Exp1()
  |
  t =<IDENTIFIER> Exp1()
  |
  t =<THIS> Exp1()
  |
  LOOKAHEAD(2) t =<NEW><IDENTIFIER><LPAREN><RPAREN> Exp1()
  |
  LOOKAHEAD(2) t =<NEW><INT><LBRACKET> Exp()<RBRACKET> Exp1()
  |
  <LPAREN>Exp()<RPAREN> Exp1()
  |
  <NOT>Exp() Exp1()
  )
}

void Exp1():
{ Token t; }
{
  (
  t=<OPERATOR> Exp() Exp1()
  |
  t=<LBRACKET>Exp()<RBRACKET> Exp1()
  |
  LOOKAHEAD(2) t=<PERIOD> <LENGTH> Exp1()
  |
  LOOKAHEAD(2) t=<PERIOD> <IDENTIFIER> <LPAREN> ExpList() <RPAREN> Exp1()
  |
  {}
  )
}


void ExpList():
{}
{
  Exp() (ExpRest())*
}

void ExpRest():
{}
{
  <COMMA> Exp()
}


